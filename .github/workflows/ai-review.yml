name: AI Code Review

on:
  workflow_dispatch:
    inputs:
      pr_number:
        description: 'Pull Request Number'
        required: true
        type: number

permissions:
  contents: read
  pull-requests: write

jobs:
  ai-review:
    runs-on: ubuntu-latest
    continue-on-error: true
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Get PR info
        id: pr-info
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: ${{ inputs.pr_number }}
            });
            core.setOutput('base_ref', pr.base.ref);
            core.setOutput('head_ref', pr.head.ref);
            return pr;
      
      - name: Get PR diff
        id: get-diff
        run: |
          git fetch origin ${{ steps.pr-info.outputs.base_ref }}
          git fetch origin ${{ steps.pr-info.outputs.head_ref }}
          DIFF=$(git diff origin/${{ steps.pr-info.outputs.base_ref }}...origin/${{ steps.pr-info.outputs.head_ref }})
          
          # Save diff to file
          echo "$DIFF" > pr_diff.txt
          
          # Check if diff is too large (limit to ~15000 chars to avoid token limits)
          DIFF_SIZE=$(wc -c < pr_diff.txt)
          if [ $DIFF_SIZE -gt 15000 ]; then
            echo "Diff too large, summarizing..."
            git diff origin/${{ github.base_ref }}...HEAD --stat > pr_diff.txt
            echo -e "\n\n---\nNote: Full diff was too large, showing summary only." >> pr_diff.txt
          fi
      
      - name: AI Code Review
        id: ai-review
        continue-on-error: true
        env:
          ARVAN_API_KEY: ${{ secrets.ARVAN_AI_API_KEY }}
        run: |
          # Read the diff
          DIFF_CONTENT=$(cat pr_diff.txt | jq -Rs .)
          
          # Prepare the review prompt
          PROMPT="Act as a senior Go and Kubernetes engineer. Review the diff and flag only true bugs, security concerns, or risky changes. Return ONLY valid JSON matching this schema:
          {
            \"summary\": string | null,
            \"comments\": [
              {
                \"path\": \"relative/file.go\",
                \"line\": number,  # line number in the PR head
                \"side\": \"RIGHT\" | \"LEFT\" (default RIGHT),
                \"body\": \"Explain the issue and impact.\",
                \"suggestion\": \"Optional replacement code without fences.\"
              }
            ]
          }
          - Use comments array only for actionable findings. Leave it empty when there are no issues.
          - Omit suggestion when not needed. When present, include only the replacement code lines.
          - Set summary to a short overview or null. If there are no issues, respond with {\"summary\":\"NO_ISSUES\",\"comments\":[]}.
          
          Code diff:
          $DIFF_CONTENT"
          
          # Call ArvanCloud AI API
          RESPONSE=$(curl -s -X POST \
            "https://arvancloudai.ir/gateway/models/GPT-5/dLeqgnGfz1C2zftmNeS4Nd9Q0Fb33Qx5JRqplYEFa4yWAFRC8saj2LMJiyMAjrDOedL4qNXb_PMDMjCSnEFqSCQkgVFnCx3T4Qtu-sruzmH-wRNhYvxHSI34EjG_nfnoOe9djzeqGnhfCJlQ-Z3zUowQQYYeg510o8t8FtAWu35poiK93SAFBYWkU_bbOCe_ZU3gg8dBzzFwpXgD2z4BWzYhz96DR1jTXOanCnI7gw4/v1/chat/completions" \
            -H "Authorization: Bearer $ARVAN_API_KEY" \
            -H "Content-Type: application/json" \
            -d "{
              \"model\": \"gpt-5\",
              \"messages\": [
                {
                  \"role\": \"system\",
                  \"content\": \"You are an expert code reviewer specializing in Go, Kubernetes, and cloud-native applications.\"
                },
                {
                  \"role\": \"user\",
                  \"content\": $(echo "$PROMPT" | jq -Rs .)
                }
              ],
              \"temperature\": 0.3,
              \"max_tokens\": 2000
            }")
          
          # Extract the review content
          REVIEW=$(echo "$RESPONSE" | jq -r '.choices[0].message.content // ""')
          HAS_ISSUES=false

          if echo "$RESPONSE" | jq -e '.error' > /dev/null 2>&1; then
            ERROR_MSG=$(echo "$RESPONSE" | jq -r '.error.message // "Unknown error"')
            REVIEW="AI review failed: $ERROR_MSG"
            echo "$REVIEW" >&2
          else
            echo "$REVIEW" > ai_raw_review.txt
            if ! echo "$REVIEW" | jq '.' > review.json 2>review_parse_error.log; then
              echo "AI review response was not valid JSON, skipping inline comments." >&2
              cat review_parse_error.log >&2
            else
              COMMENTS_COUNT=$(jq '.comments | length' review.json 2>/dev/null || echo 0)
              SUMMARY=$(jq -r '.summary // ""' review.json)
              if [ "$COMMENTS_COUNT" -gt 0 ]; then
                HAS_ISSUES=true
              elif [ "$SUMMARY" = "NO_ISSUES" ]; then
                :
              else
                SUMMARY=$(echo "$SUMMARY" | tr -d '[:space:]')
                if [ -z "$SUMMARY" ]; then
                  jq '.summary = "NO_ISSUES"' review.json > review.tmp && mv review.tmp review.json
                fi
              fi
            fi
          fi

          # Persist summary for diagnostics
          if [ -f review.json ]; then
            jq -r '.summary // "NO_ISSUES"' review.json 2>/dev/null > summary.txt || echo "$REVIEW" > summary.txt
          else
            echo "$REVIEW" > summary.txt
          fi
          echo "has_issues=$HAS_ISSUES" >> "$GITHUB_OUTPUT"
      
      - name: Post AI Review Comment
        if: steps.ai-review.outputs.has_issues == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const core = require('@actions/core');

            if (!fs.existsSync('review.json')) {
              core.info('No structured review to post.');
              return;
            }

            const data = JSON.parse(fs.readFileSync('review.json', 'utf8'));
            const summary = data.summary && data.summary !== 'NO_ISSUES' ? data.summary : '';
            const comments = Array.isArray(data.comments) ? data.comments : [];

            const formattedComments = comments
              .map((item, index) => {
                if (!item || !item.path || item.path.trim() === '' || item.line === undefined || item.body === undefined) {
                  core.warning(`Skipping malformed comment at index ${index}`);
                  return null;
                }

                const lineNumber = Number(item.line);
                if (!Number.isInteger(lineNumber) || lineNumber <= 0) {
                  core.warning(`Invalid line number for comment at index ${index}`);
                  return null;
                }

                const body = String(item.body || '').trim();
                if (!body) {
                  core.warning(`Empty body for comment at index ${index}`);
                  return null;
                }

                const parts = [body];

                if (item.suggestion) {
                  const suggestion = String(item.suggestion).trimEnd();
                  if (suggestion) {
                    parts.push('```suggestion');
                    parts.push(suggestion);
                    parts.push('```');
                  }
                }

                return {
                  path: item.path,
                  line: lineNumber,
                  side: item.side === 'LEFT' ? 'LEFT' : 'RIGHT',
                  body: parts.join('\n\n')
                };
              })
              .filter(Boolean);

            if (!formattedComments.length && !summary) {
              core.info('AI review found no actionable comments.');
              return;
            }

            await github.rest.pulls.createReview({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: Number(process.env.PR_NUMBER),
              event: 'COMMENT',
              body: summary,
              comments: formattedComments
            });
        env:
          PR_NUMBER: ${{ inputs.pr_number }}
